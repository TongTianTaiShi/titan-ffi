/*! \file */
/*******************************************
 *                                         *
 *  File auto-generated by `::safer_ffi`.  *
 *                                         *
 *  Do not manually edit this file.        *
 *                                         *
 *******************************************/

#ifndef __RUST_FILCRYPTO__
#define __RUST_FILCRYPTO__

#ifdef __cplusplus
extern "C" {
#endif


#include <stddef.h>
#include <stdint.h>

typedef struct { uint8_t idx[96]; } uint8_96_array_t;

void destroy_box_bls_digest (
    uint8_96_array_t * ptr);

typedef struct { uint8_t idx[32]; } uint8_32_array_t;

void destroy_box_bls_private_key (
    uint8_32_array_t * ptr);

typedef struct { uint8_t idx[48]; } uint8_48_array_t;

void destroy_box_bls_public_key (
    uint8_48_array_t * ptr);

void destroy_box_bls_signature (
    uint8_96_array_t * ptr);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 * 
 *  # C layout (for some given type T)
 * 
 *  ```c
 *  typedef struct {
 *      // Cannot be NULL
 *      T * ptr;
 *      size_t len;
 *  } slice_T;
 *  ```
 * 
 *  # Nullable pointer?
 * 
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_uint8 {

    uint8_t const * ptr;

    size_t len;

} slice_ref_uint8_t;

/** \brief
 *  Compute the digest of a message
 * 
 *  # Arguments
 * 
 *  * `message` - reference to a message byte array
 */
uint8_96_array_t * hash (
    slice_ref_uint8_t message);

/** \brief
 *  Aggregate signatures together into a new signature
 * 
 *  # Arguments
 * 
 *  * `flattened_signatures` - byte array containing signatures
 * 
 *  Returns `None` on error. Result must be freed using `destroy_aggregate_response`.
 */
uint8_96_array_t * aggregate (
    slice_ref_uint8_t flattened_signatures);


#include <stdbool.h>

/** \brief
 *  Verify that a signature is the aggregated signature of hashes - pubkeys
 * 
 *  # Arguments
 * 
 *  * `signature`             - signature byte array (SIGNATURE_BYTES long)
 *  * `flattened_digests`     - byte array containing digests
 *  * `flattened_public_keys` - byte array containing public keys
 */
bool verify (
    slice_ref_uint8_t signature,
    slice_ref_uint8_t flattened_digests,
    slice_ref_uint8_t flattened_public_keys);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 * 
 *  # C layout (for some given type T)
 * 
 *  ```c
 *  typedef struct {
 *      // Cannot be NULL
 *      T * ptr;
 *      size_t len;
 *  } slice_T;
 *  ```
 * 
 *  # Nullable pointer?
 * 
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_size {

    size_t const * ptr;

    size_t len;

} slice_ref_size_t;

/** \brief
 *  Verify that a signature is the aggregated signature of the hashed messages
 * 
 *  # Arguments
 * 
 *  * `signature`             - signature byte array (SIGNATURE_BYTES long)
 *  * `messages`              - array containing the pointers to the messages
 *  * `messages_sizes`        - array containing the lengths of the messages
 *  * `messages_len`          - length of the two messages arrays
 *  * `flattened_public_keys` - byte array containing public keys
 */
bool hash_verify (
    slice_ref_uint8_t signature,
    slice_ref_uint8_t flattened_messages,
    slice_ref_size_t message_sizes,
    slice_ref_uint8_t flattened_public_keys);

/** \brief
 *  Generate a new private key
 */
uint8_32_array_t * private_key_generate (void);

/** \brief
 *  Generate a new private key with seed
 * 
 *  **Warning**: Use this function only for testing or with very secure seeds
 * 
 *  # Arguments
 * 
 *  * `raw_seed` - a seed byte array with 32 bytes
 */
uint8_32_array_t * private_key_generate_with_seed (
    uint8_32_array_t const * raw_seed);

/** \brief
 *  Sign a message with a private key and return the signature
 * 
 *  # Arguments
 * 
 *  * `raw_private_key` - private key byte array
 *  * `message` - message byte array
 * 
 *  Returns `None` when passed invalid arguments.
 */
uint8_96_array_t * private_key_sign (
    slice_ref_uint8_t raw_private_key,
    slice_ref_uint8_t message);

/** \brief
 *  Generate the public key for a private key
 * 
 *  # Arguments
 * 
 *  * `raw_private_key` - private key byte array
 * 
 *  Returns `None` when passed invalid arguments.
 */
uint8_48_array_t * private_key_public_key (
    slice_ref_uint8_t raw_private_key);

/** \brief
 *  Returns a zero signature, used as placeholder in Filecoin.
 * 
 *  The return value is a pointer to a compressed signature in bytes, of length `SIGNATURE_BYTES`
 */
uint8_96_array_t * create_zero_signature (void);


#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* __RUST_FILCRYPTO__ */
